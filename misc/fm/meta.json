{
  "methods": {
    "FM": {
      "desc": "callable helper - returns \"<package-name> - version <version>\"",
      "params": [],
      "examples": ["FM()"]
    },
    "getInfo": {
      "desc": "returns info string",
      "params": [],
      "examples": ["FM.getInfo()"]
    },
    "getName": {
      "desc": "returns package name",
      "params": [],
      "examples": ["FM.getName()"]
    },
    "getVersion": {
      "desc": "returns package version",
      "params": [],
      "examples": ["FM.getVersion()"]
    },
    "getBuildType": {
      "desc": "returns build type (Node:Dev | Electron:Dev | Electron:Dist)",
      "params": [],
      "examples": ["FM.getBuildType()"]
    },
    "exit": {
      "desc": "exits/quits the application cleanly (works for both Node dev and Electron builds)",
      "params": [],
      "examples": ["FM.exit()"]
    },
    "getPanels": {
      "desc": "returns object with active and other panels { active: {...}, other: {...} } each containing side, path, and selection (selection relative by default, absolute if param is false)",
      "params": [
        "relativeSelection? (boolean - default true, return relative selection)"
      ],
      "examples": ["FM.getPanels()", "FM.getPanels(false)"]
    },
    "getActivePanel": {
      "desc": "returns object with side, path, and selection for the active panel (selection relative by default, absolute if param is false)",
      "params": [
        "relativeSelection? (boolean - default true, return relative selection)"
      ],
      "examples": ["FM.getActivePanel()", "FM.getActivePanel(false)"]
    },
    "getOtherPanel": {
      "desc": "returns object with side, path, and selection for the other panel (selection relative by default, absolute if param is false)",
      "params": [
        "relativeSelection? (boolean - default true, return relative selection)"
      ],
      "examples": ["FM.getOtherPanel()", "FM.getOtherPanel(false)"]
    },
    "getActivePanelSide": {
      "desc": "returns 'left' or 'right' indicating which panel is currently active",
      "params": [],
      "examples": ["FM.getActivePanelSide()"]
    },
    "getOtherPanelSide": {
      "desc": "returns 'left' or 'right' indicating which panel is currently other/inactive",
      "params": [],
      "examples": ["FM.getOtherPanelSide()"]
    },
    "setActivePanelSide": {
      "desc": "sets which panel should be active ('left' or 'right', defaults to 'left')",
      "params": ["side? (string - 'left' or 'right', default 'left')"],
      "examples": [
        "FM.setActivePanelSide('left')",
        "FM.setActivePanelSide('right')"
      ]
    },
    "toggleActivePanelSide": {
      "desc": "toggles the active panel between left and right",
      "params": [],
      "examples": ["FM.toggleActivePanelSide()"]
    },
    "swapPanels": {
      "desc": "swaps the paths of the left and right panels",
      "params": [],
      "examples": ["FM.swapPanels()"]
    },
    "refreshActivePanel": {
      "desc": "refreshes the file list of the active panel",
      "params": [],
      "examples": ["FM.refreshActivePanel()"]
    },
    "refreshOtherPanel": {
      "desc": "refreshes the file list of the other panel",
      "params": [],
      "examples": ["FM.refreshOtherPanel()"]
    },
    "refreshBothPanels": {
      "desc": "refreshes the file list of both panels",
      "params": [],
      "examples": ["FM.refreshBothPanels()"]
    },
    "setActivePanelPath": {
      "desc": "sets the path of the active panel (async, returns {success, error?})",
      "params": ["path (string - absolute path to navigate to)"],
      "examples": ["await FM.setActivePanelPath('/Users/name/Documents')"]
    },
    "setOtherPanelPath": {
      "desc": "sets the path of the other panel (async, returns {success, error?})",
      "params": ["path (string - absolute path to navigate to)"],
      "examples": ["await FM.setOtherPanelPath('/tmp')"]
    },
    "setActivePanelSelection": {
      "desc": "sets the selection for the active panel (returns {selected, notFound})",
      "params": [
        "items (array - names or absolute paths)",
        "ignoreCase? (boolean - default false, case-insensitive)",
        "reset? (boolean - default true, reset selection)"
      ],
      "examples": [
        "FM.setActivePanelSelection(['file.txt', 'image.png'])",
        "FM.setActivePanelSelection(['FILE.TXT'], true)",
        "FM.setActivePanelSelection(['new.pdf'], false, false)"
      ]
    },
    "setOtherPanelSelection": {
      "desc": "sets the selection for the other panel (returns {selected, notFound})",
      "params": [
        "items (array - names or absolute paths)",
        "ignoreCase? (boolean - default false, case-insensitive)",
        "reset? (boolean - default true, reset selection)"
      ],
      "examples": [
        "FM.setOtherPanelSelection(['doc.pdf'])",
        "FM.setOtherPanelSelection(['README.MD'], true)",
        "FM.setOtherPanelSelection(['data.json'], false, false)"
      ]
    },
    "resetActivePanelSelection": {
      "desc": "clears the selection for the active panel (unselects all items)",
      "params": [],
      "examples": ["FM.resetActivePanelSelection()"]
    },
    "resetOtherPanelSelection": {
      "desc": "clears the selection for the other panel (unselects all items)",
      "params": [],
      "examples": ["FM.resetOtherPanelSelection()"]
    },
    "resetBothPanelsSelections": {
      "desc": "clears the selection for both panels (unselects all items in both panels)",
      "params": [],
      "examples": ["FM.resetBothPanelsSelections()"]
    },
    "invertActivePanelSelection": {
      "desc": "inverts the selection for the active panel (selects unselected, unselects selected)",
      "params": [],
      "examples": ["FM.invertActivePanelSelection()"]
    },
    "invertOtherPanelSelection": {
      "desc": "inverts the selection for the other panel (selects unselected, unselects selected)",
      "params": [],
      "examples": ["FM.invertOtherPanelSelection()"]
    },
    "setActivePanelQuickSelect": {
      "desc": "performs quick select on active panel using a pattern (returns count of items selected)",
      "params": [
        "pattern (string - wildcard or regex)",
        "useRegex? (boolean - default false)",
        "caseSensitive? (boolean - default false)",
        "resetSelection? (boolean - default true)"
      ],
      "examples": [
        "FM.setActivePanelQuickSelect(\"*.txt\")",
        "FM.setActivePanelQuickSelect(\"^test\", true)",
        "FM.setActivePanelQuickSelect(\"File\", false, true)",
        "FM.setActivePanelQuickSelect(\"*.js\", false, false, false)",
        "FM.setActivePanelQuickSelect(\"_FILES_ONLY_\")",
        "FM.setActivePanelQuickSelect(\"_FOLDERS_ONLY_\")",
        "FM.setActivePanelQuickSelect(\"_ZIP_FILES_ONLY_\")"
      ]
    },
    "setOtherPanelQuickSelect": {
      "desc": "performs quick select on other panel using a pattern (returns count of items selected)",
      "params": [
        "pattern (string - wildcard or regex)",
        "useRegex? (boolean - default false)",
        "caseSensitive? (boolean - default false)",
        "resetSelection? (boolean - default true)"
      ],
      "examples": [
        "FM.setOtherPanelQuickSelect(\"*.jpg\")",
        "FM.setOtherPanelQuickSelect(\"\\\\.(png|gif)$\", true)",
        "FM.setOtherPanelQuickSelect(\"IMG\", false, true)",
        "FM.setOtherPanelQuickSelect(\"doc*\", false, false, false)",
        "FM.setOtherPanelQuickSelect(\"_FILES_ONLY_\")",
        "FM.setOtherPanelQuickSelect(\"_FOLDERS_ONLY_\")",
        "FM.setOtherPanelQuickSelect(\"_ZIP_FILES_ONLY_\")"
      ]
    },
    "setActivePanelQuickUnselect": {
      "desc": "performs quick unselect on active panel using a pattern (returns count of items unselected)",
      "params": [
        "pattern (string - wildcard or regex)",
        "useRegex? (boolean - default false)",
        "caseSensitive? (boolean - default false)",
        "resetSelection? (boolean - default true)"
      ],
      "examples": [
        "FM.setActivePanelQuickUnselect(\"*.tmp\")",
        "FM.setActivePanelQuickUnselect(\"\\\\.(log|bak)$\", true)",
        "FM.setActivePanelQuickUnselect(\"Test\", false, true)",
        "FM.setActivePanelQuickUnselect(\"temp*\", false, false, false)",
        "FM.setActivePanelQuickUnselect(\"_FILES_ONLY_\")",
        "FM.setActivePanelQuickUnselect(\"_FOLDERS_ONLY_\")",
        "FM.setActivePanelQuickUnselect(\"_ZIP_FILES_ONLY_\")"
      ]
    },
    "setOtherPanelQuickUnselect": {
      "desc": "performs quick unselect on other panel using a pattern (returns count of items unselected)",
      "params": [
        "pattern (string - wildcard or regex)",
        "useRegex? (boolean - default false)",
        "caseSensitive? (boolean - default false)",
        "resetSelection? (boolean - default true)"
      ],
      "examples": [
        "FM.setOtherPanelQuickUnselect(\"test*\")",
        "FM.setOtherPanelQuickUnselect(\"^old\", true)",
        "FM.setOtherPanelQuickUnselect(\"Backup\", false, true)",
        "FM.setOtherPanelQuickUnselect(\"*cache*\", false, false, false)",
        "FM.setOtherPanelQuickUnselect(\"_FILES_ONLY_\")",
        "FM.setOtherPanelQuickUnselect(\"_FOLDERS_ONLY_\")",
        "FM.setOtherPanelQuickUnselect(\"_ZIP_FILES_ONLY_\")"
      ]
    },
    "setActivePanelQuickFilter": {
      "desc": "sets a filter pattern for the active panel to show only matching items (returns count of matching items)",
      "params": [
        "pattern (string - wildcard or regex)",
        "useRegex? (boolean - default false)",
        "caseSensitive? (boolean - default false)"
      ],
      "examples": [
        "FM.setActivePanelQuickFilter(\"*.js\")",
        "FM.setActivePanelQuickFilter(\"\\.(ts|tsx)$\", true)",
        "FM.setActivePanelQuickFilter(\"Component\", false, true)",
        "FM.setActivePanelQuickFilter(\"_FILES_ONLY_\")",
        "FM.setActivePanelQuickFilter(\"_FOLDERS_ONLY_\")",
        "FM.setActivePanelQuickFilter(\"_ZIP_FILES_ONLY_\")"
      ]
    },
    "setOtherPanelQuickFilter": {
      "desc": "sets a filter pattern for the other panel to show only matching items (returns count of matching items)",
      "params": [
        "pattern (string - wildcard or regex)",
        "useRegex? (boolean - default false)",
        "caseSensitive? (boolean - default false)"
      ],
      "examples": [
        "FM.setOtherPanelQuickFilter(\"doc\")",
        "FM.setOtherPanelQuickFilter(\"^[A-Z]\", true)",
        "FM.setOtherPanelQuickFilter(\"README\", false, true)",
        "FM.setOtherPanelQuickFilter(\"_FILES_ONLY_\")",
        "FM.setOtherPanelQuickFilter(\"_FOLDERS_ONLY_\")",
        "FM.setOtherPanelQuickFilter(\"_ZIP_FILES_ONLY_\")"
      ]
    },
    "setActivePanelQuickFilterFiles": {
      "desc": "filters the active panel to show only files (returns count of files)",
      "params": [],
      "examples": ["FM.setActivePanelQuickFilterFiles()"]
    },
    "setOtherPanelQuickFilterFiles": {
      "desc": "filters the other panel to show only files (returns count of files)",
      "params": [],
      "examples": ["FM.setOtherPanelQuickFilterFiles()"]
    },
    "setActivePanelQuickFilterFolders": {
      "desc": "filters the active panel to show only folders (returns count of folders)",
      "params": [],
      "examples": ["FM.setActivePanelQuickFilterFolders()"]
    },
    "setOtherPanelQuickFilterFolders": {
      "desc": "filters the other panel to show only folders (returns count of folders)",
      "params": [],
      "examples": ["FM.setOtherPanelQuickFilterFolders()"]
    },
    "setActivePanelQuickFilterZipFiles": {
      "desc": "filters the active panel to show only zip/archive files (returns count of zip files)",
      "params": [],
      "examples": ["FM.setActivePanelQuickFilterZipFiles()"]
    },
    "setOtherPanelQuickFilterZipFiles": {
      "desc": "filters the other panel to show only zip/archive files (returns count of zip files)",
      "params": [],
      "examples": ["FM.setOtherPanelQuickFilterZipFiles()"]
    },
    "resetActivePanelQuickFilter": {
      "desc": "clears the filter for the active panel (shows all items, returns count of items)",
      "params": [],
      "examples": ["FM.resetActivePanelQuickFilter()"]
    },
    "resetOtherPanelQuickFilter": {
      "desc": "clears the filter for the other panel (shows all items, returns count of items)",
      "params": [],
      "examples": ["FM.resetOtherPanelQuickFilter()"]
    },
    "resetBothPanelQuickFilter": {
      "desc": "clears the filter for both panels (shows all items, returns combined count of items)",
      "params": [],
      "examples": ["FM.resetBothPanelQuickFilter()"]
    },
    "createActivePanelNewFile": {
      "desc": "creates a new file in the active panel using the app's new file handler (async). If `name` is provided it will be used (and will be made unique if already exists); it may include nested path segments (e.g., 'dir/subdir/file.txt' or 'dir\\subdir\\file.txt') and missing parents will be created. The optional `content` parameter will be written into the file verbatim; newline characters like `` are supported and will be reproduced as line breaks in the created file. Alternatively, you may pass `content` using an ES template literal (backticks), and the literal newlines will be preserved (no `` escapes required). Otherwise a default 'New File' will be used. Returns an object with { success, result, createdPath } where result contains the server response (e.g., jobId). If the operation triggers an archive (zip) update, the method will wait until the zip update completes before resolving (useful when creating files inside zip archives).",
      "params": [
        "name? (string - filename, e.g. 'MyFile.txt')",
        "content? (string - optional initial content)"
      ],
      "examples": [
        "await FM.createActivePanelNewFile()",
        "await FM.createActivePanelNewFile('MyFile.txt')",
        "await FM.createActivePanelNewFile('dir/subdir/MyFile.txt', 'initial content...')",
        "await FM.createActivePanelNewFile('MyFile.txt', 'Initial content')",
        "await FM.createActivePanelNewFile('MyFile.txt', 'First line\\nSecond line\\nThird line')",
        "await FM.createActivePanelNewFile('MyFile.txt', `First line\\nSecond line\\nThird line`) // or using template literal and multlines in it"
      ]
    },
    "createOtherPanelNewFile": {
      "desc": "creates a new file in the other (inactive) panel using the app's new file handler (async). If `name` is provided it will be used (and will be made unique if already exists); it may include nested path segments (e.g., 'dir/subdir/file.txt' or 'dir\\subdir\\file.txt') and missing parents will be created. The optional `content` parameter will be written into the file verbatim; newline characters like `` are supported and will be reproduced as line breaks in the created file. Alternatively, you may pass `content` using an ES template literal (backticks), and the literal newlines will be preserved (no `` escapes required). Otherwise a default 'New File' will be used. Returns an object with { success, result, createdPath } where result contains the server response (e.g., jobId). If the operation triggers an archive (zip) update, the method will wait until the zip update completes before resolving (useful when creating files inside zip archives).",
      "params": [
        "name? (string - filename, e.g. 'MyFile.txt')",
        "content? (string - optional initial content)"
      ],
      "examples": [
        "await FM.createOtherPanelNewFile()",
        "await FM.createOtherPanelNewFile('MyFile.txt')",
        "await FM.createOtherPanelNewFile('MyFile.txt', 'Initial content')",
        "await FM.createOtherPanelNewFile('MyFile.txt', 'First line\\nSecond line')",
        "await FM.createOtherPanelNewFile('MyFile.txt', `First line\\nSecond line`) // or using template literal and multlines in it"
      ]
    },
    "createActivePanelNewFolder": {
      "desc": "creates a new folder in the active panel using the app's new folder handler (async). If `name` is provided it will be used; it may include nested paths separated by '/' or '\\' (subfolders will be created). The last segment will be made unique if necessary. Returns an object with { success, result, createdPath } where `result` contains the server response (e.g., jobId). If the operation triggers an archive (zip) update, the method will wait until the zip update completes before resolving.",
      "params": ["name? (string - folder name, e.g. 'MyFolder')"],
      "examples": [
        "await FM.createActivePanelNewFolder()",
        "await FM.createActivePanelNewFolder('MyFolder')",
        "await FM.createActivePanelNewFolder('dir/subdir/new')",
        "await FM.createActivePanelNewFolder('dir\\subdir\\new') // Windows-style separators preserved and normalized",
        "await FM.createActivePanelNewFolder('MyFolder') // if exists, a unique suffix is appended"
      ]
    },
    "createOtherPanelNewFolder": {
      "desc": "creates a new folder in the other (inactive) panel using the app's new folder handler (async). If `name` is provided it will be used (and will be made unique if already exists), otherwise a default 'New Folder' will be used. Returns an object with { success, result, createdPath } where result contains the server response (e.g., jobId). If the operation triggers an archive (zip) update, the method will wait until the zip update completes before resolving.",
      "params": ["name? (string - folder name, e.g. 'MyFolder')"],
      "examples": [
        "await FM.createOtherPanelNewFolder()",
        "await FM.createOtherPanelNewFolder('MyFolder')",
        "await FM.createOtherPanelNewFolder('dir\\subdir\\new') // windows-style separators accepted",
        "await FM.createOtherPanelNewFolder('MyFolder') // uniqueness checks apply"
      ]
    },
    "editActivePanelFile": {
      "desc": "Writes (edits) content to a file in the active panel. If `filePath` is a relative path it will be resolved relative to the active panel path. The `content` parameter is written verbatim; newline characters like `` are supported and template-literal (backtick) strings will preserve literal newlines. Returns an object with { success, result, createdPath } where result contains server response (e.g., jobId for zip operations). If the operation triggers an archive (zip) update, the method will wait until the zip update completes before resolving.",
      "params": [
        "filePath (string - relative or absolute path to file)",
        "content (string - file content)"
      ],
      "examples": [
        "await FM.editActivePanelFile('file.txt', 'Simple content')",
        "await FM.editActivePanelFile('dir/sub/file.txt', 'First line\\nSecond line')",
        "await FM.editActivePanelFile('file.txt', `Line 1\nLine 2`) // using backticks template literal"
      ]
    },
    "editOtherPanelFile": {
      "desc": "Writes (edits) content to a file in the other (inactive) panel. If `filePath` is a relative path it will be resolved relative to the other panel path. The `content` parameter is written verbatim; newline characters like `` are supported and template-literal (backtick) strings will preserve literal newlines. Returns an object with { success, result, createdPath } where result contains server response (e.g., jobId for zip operations). If the operation triggers an archive (zip) update, the method will wait until the zip update completes before resolving.",
      "params": [
        "filePath (string - relative or absolute path to file)",
        "content (string - file content)"
      ],
      "examples": [
        "await FM.editOtherPanelFile('file.txt', 'Simple content')",
        "await FM.editOtherPanelFile('dir/sub/file.txt', 'First line\\nSecond line')",
        "await FM.editOtherPanelFile('file.txt', `Line 1\nLine 2`) // using backticks template literal"
      ]
    },
    "selectActivePanelFiles": {
      "desc": "selects only files (non-folder, non-parent items) in the active panel (returns count of files selected)",
      "params": [],
      "examples": ["FM.selectActivePanelFiles()"]
    },
    "selectOtherPanelFiles": {
      "desc": "selects only files (non-folder, non-parent items) in the other panel (returns count of files selected)",
      "params": [],
      "examples": ["FM.selectOtherPanelFiles()"]
    },
    "selectActivePanelFolders": {
      "desc": "selects only folders in the active panel (returns count of folders selected)",
      "params": [],
      "examples": ["FM.selectActivePanelFolders()"]
    },
    "selectOtherPanelFolders": {
      "desc": "selects only folders in the other panel (returns count of folders selected)",
      "params": [],
      "examples": ["FM.selectOtherPanelFolders()"]
    },
    "selectActivePanelZipFiles": {
      "desc": "selects only zip/archive files in the active panel (returns count of zip files selected)",
      "params": [],
      "examples": ["FM.selectActivePanelZipFiles()"]
    },
    "selectOtherPanelZipFiles": {
      "desc": "selects only zip/archive files in the other panel (returns count of zip files selected)",
      "params": [],
      "examples": ["FM.selectOtherPanelZipFiles()"]
    },
    "unselectActivePanelFiles": {
      "desc": "unselects only files in the active panel (returns count of items remaining in selection)",
      "params": [],
      "examples": ["FM.unselectActivePanelFiles()"]
    },
    "unselectOtherPanelFiles": {
      "desc": "unselects only files in the other panel (returns count of items remaining in selection)",
      "params": [],
      "examples": ["FM.unselectOtherPanelFiles()"]
    },
    "unselectActivePanelFolders": {
      "desc": "unselects only folders in the active panel (returns count of items remaining in selection)",
      "params": [],
      "examples": ["FM.unselectActivePanelFolders()"]
    },
    "unselectOtherPanelFolders": {
      "desc": "unselects only folders in the other panel (returns count of items remaining in selection)",
      "params": [],
      "examples": ["FM.unselectOtherPanelFolders()"]
    },
    "unselectActivePanelZipFiles": {
      "desc": "unselects only zip/archive files in the active panel (returns count of items remaining in selection)",
      "params": [],
      "examples": ["FM.unselectActivePanelZipFiles()"]
    },
    "unselectOtherPanelZipFiles": {
      "desc": "unselects only zip/archive files in the other panel (returns count of items remaining in selection)",
      "params": [],
      "examples": ["FM.unselectOtherPanelZipFiles()"]
    },
    "getActivePanelPath": {
      "desc": "returns the absolute path of the currently active panel",
      "params": [],
      "examples": ["FM.getActivePanelPath()"]
    },
    "getOtherPanelPath": {
      "desc": "returns the absolute path of the currently other panel",
      "params": [],
      "examples": ["FM.getOtherPanelPath()"]
    },
    "getActivePanelSelection": {
      "desc": "returns array of paths for selected items in the active panel (relative by default, absolute if param is false)",
      "params": [
        "relative? (boolean - default true, return relative paths when true)"
      ],
      "examples": ["FM.getActivePanelSelection()"]
    },
    "getOtherPanelSelection": {
      "desc": "returns array of paths for selected items in the other panel (relative by default, absolute if param is false)",
      "params": [
        "relative? (boolean - default true, return relative paths when true)"
      ],
      "examples": ["FM.getOtherPanelSelection()"]
    },
    "toString": {
      "desc": "returns info string (same as FM())",
      "params": [],
      "examples": ["FM.toString()"]
    },
    "help": {
      "desc": "prints this help. You may pass a filter string (e.g., 'Active', 'File') to limit methods and properties returned. You can also pass a second numeric argument to control line wrapping (max line length) or pass the value as `maxLineLength` in an options object. Example: `FM.help('active', 120)` or `FM.help({ filter: 'File', returnOutput: true, maxLineLength: 120 })`.",
      "params": [
        "filter? (string - optional case-insensitive filter to reduce results)",
        "returnOutput? (boolean - return as string rather than printing)",
        "maxLineLength? (number - optional maximum line length, defaults to 72)"
      ],
      "examples": [
        "FM.help()",
        "FM.help('Active')",
        "FM.help({ filter: 'File', returnOutput: true }) //you can feed this to console.log() for example",
        "FM.help('file', 120)"
      ]
    },
    "startActivePanelTerminal": {
      "desc": "Starts an interactive Terminal in the active panel's path (or optional override). If `startingPath` is provided it will attempt to start in that path; if invalid, it falls back to the active panel's path. Optionally pass an `initialCommand` that will be auto-typed and executed (Enter). Returns an object with { success, result }.",
      "params": [
        "startingPath? (string - optional path to start terminal in; if relative, resolved against active panel path)",
        "initialCommand? (string - optional command to auto-type and execute in the terminal)"
      ],
      "examples": [
        "await FM.startActivePanelTerminal()",
        "await FM.startActivePanelTerminal('/Users/me/project')",
        "await FM.startActivePanelTerminal('relative/subdir', 'pwd')",
        "await FM.startActivePanelTerminal(null, 'pwd') // if you just want to run a command in the active panel path",
        "await FM.startActivePanelTerminal('/path/that/does/not/exist', 'ls -la') // falls back to active panel if path not found"
      ]
    },
    "startOtherPanelTerminal": {
      "desc": "Starts an interactive Terminal in the other (inactive) panel's path (or an optional override). If `startingPath` is provided it will attempt to start in that path; if invalid, it falls back to the other panel's path. Optionally pass an `initialCommand` that will be auto-typed and executed (Enter). Returns an object with { success, result }.",
      "params": [
        "startingPath? (string - optional path to start terminal in; if relative, resolved against other panel path)",
        "initialCommand? (string - optional command to auto-type and execute in the terminal)"
      ],
      "examples": [
        "await FM.startOtherPanelTerminal()",
        "await FM.startOtherPanelTerminal('/Users/me/project')",
        "await FM.startOtherPanelTerminal('relative/subdir', 'pwd')",
        "await FM.startOtherPanelTerminal(null, 'pwd') // if you just want to run a command in the other panel path",
        "await FM.startOtherPanelTerminal('/path/that/does/not/exist', 'ls -la') // falls back to other panel if path not found"
      ]
    },
    "decompressToActivePanel": {
      "desc": "Decompress selected ZIP archive(s) into the active panel (async). If `itemsToExtract` array is provided it will extract only those entries from the first selected archive.",
      "params": [
        "itemsToExtract? (array - optional list of paths, glob patterns or regular expressions (e.g. ['*.jpg','docs/*.txt','/^images\\/.*\\.jpg$/i']) inside the archive to extract)",
        "overwrite? (boolean|string - optional; boolean true -> overwrite / false -> skip; or string: 'overwrite'|'skip' or server policy tokens: 'if_newer','smaller_only','no_zero_length','size_differs','cancel')"
      ],
      "examples": [
        "await FM.decompressToActivePanel()",
        "await FM.decompressToActivePanel(['folder/file.txt'])",
        "await FM.decompressToActivePanel(['*.jpg','docs/*.txt']) // use wildcards to select by pattern",
        "await FM.decompressToActivePanel(['/^images\\/.*\\.jpg$/i']) // use a regex (string literal form) to match entries",
        "// Overwrite parameter: pass a boolean or one of the server decision tokens below.",
        "// - boolean: true -> overwrite (no prompts), false -> skip (no prompts)",
        "// - string tokens: 'overwrite' | 'skip' (no prompts), or server policy tokens:",
        "//   'if_newer'     - copy only if destination is missing or older",
        "//   'smaller_only' - replace destination if it's smaller",
        "//   'no_zero_length' - skip when source entry is empty",
        "//   'size_differs' - overwrite when sizes differ",
        "//   'cancel'       - cancel the extraction",
        "await FM.decompressToActivePanel(null, true) // overwrite (no prompts)",
        "await FM.decompressToActivePanel(null, 'overwrite') // overwrite (no prompts)",
        "await FM.decompressToActivePanel(null, false) // skip (no prompts)",
        "await FM.decompressToActivePanel(null, 'skip') // skip (no prompts)",
        "await FM.decompressToActivePanel(null, 'if_newer') // copy only if dest missing or older",
        "await FM.decompressToActivePanel(null, 'smaller_only') // replace dest if smaller",
        "await FM.decompressToActivePanel(null, 'no_zero_length') // skip when source entry is empty",
        "await FM.decompressToActivePanel(null, 'size_differs') // overwrite when sizes differ",
        "await FM.decompressToActivePanel(null, 'cancel') // cancel the whole extraction",
        "// combine itemsToExtract with an explicit decision:",
        "await FM.decompressToActivePanel(['a.txt','b/c.jpg'], 'if_newer')"
      ]
    },
    "decompressToOtherPanel": {
      "desc": "Decompress selected ZIP archive(s) into the other (inactive) panel (async). Optional `itemsToExtract` applies to the first selected archive. Optional `overwrite` controls conflict resolution (see examples).",
      "params": [
        "itemsToExtract? (array - optional list of paths, glob patterns or regular expressions (e.g. ['*.jpg','docs/*.txt','/^images\\/.*\\.jpg$/i']) inside the archive to extract)",
        "overwrite? (boolean|string - optional; boolean true -> overwrite / false -> skip; or string: 'overwrite'|'skip' or server policy tokens: 'if_newer','smaller_only','no_zero_length','size_differs','cancel')"
      ],
      "examples": [
        "await FM.decompressToOtherPanel()",
        "await FM.decompressToOtherPanel(['folder/file.txt'])",
        "await FM.decompressToOtherPanel(['*.jpg','docs/*.txt']) // use wildcards to select by pattern",
        "await FM.decompressToOtherPanel(['/^images\\/.*\\.jpg$/i']) // use a regex (string literal form) to match entries",
        "// Overwrite parameter: pass a boolean or one of the server decision tokens below.",
        "// - boolean: true -> overwrite (no prompts), false -> skip (no prompts)",
        "// - string tokens: 'overwrite' | 'skip' (no prompts), or server policy tokens:",
        "//   'if_newer'     - copy only if destination is missing or older",
        "//   'smaller_only' - replace destination if it's smaller",
        "//   'no_zero_length' - skip when source entry is empty",
        "//   'size_differs' - overwrite when sizes differ",
        "//   'cancel'       - cancel the extraction",
        "await FM.decompressToOtherPanel(null, true) // overwrite (no prompts)",
        "await FM.decompressToOtherPanel(null, 'overwrite') // overwrite (no prompts)",
        "await FM.decompressToOtherPanel(null, false) // skip (no prompts)",
        "await FM.decompressToOtherPanel(null, 'skip') // skip (no prompts)",
        "await FM.decompressToOtherPanel(null, 'if_newer') // copy only if dest missing or older",
        "await FM.decompressToOtherPanel(null, 'smaller_only') // replace dest if smaller",
        "await FM.decompressToOtherPanel(null, 'no_zero_length') // skip when source entry is empty",
        "await FM.decompressToOtherPanel(null, 'size_differs') // overwrite when sizes differ",
        "await FM.decompressToOtherPanel(null, 'cancel') // cancel the whole extraction",
        "// combine itemsToExtract with an explicit decision:",
        "await FM.decompressToOtherPanel(['a.txt','b/c.jpg'], 'if_newer')"
      ]
    },
    "decompressInSubfolderToActivePanel": {
      "desc": "Decompress selected ZIP archive(s) into archive-named subfolder(s) inside the active panel (async). Automatically appends suffixes if folder names collide. Supports optional `itemsToExtract` which accepts exact paths, wildcard patterns, or regular expressions.",
      "params": [
        "itemsToExtract? (array - optional list of paths, glob patterns or regular expressions (e.g. ['*.jpg','docs/*.txt','/^images\\/.*\\.jpg$/i']) inside the archive to extract)"
      ],
      "examples": [
        "await FM.decompressInSubfolderToActivePanel()",
        "await FM.decompressInSubfolderToActivePanel(['a/b.txt'])",
        "await FM.decompressInSubfolderToActivePanel(['*.jpg','docs/*.txt']) // use wildcards to select by pattern",
        "await FM.decompressInSubfolderToActivePanel(['/^images\\/.*\\.jpg$/i']) // use a regex (string literal form) to match entries"
      ]
    },
    "decompressInSubfolderToOtherPanel": {
      "desc": "Decompress selected ZIP archive(s) into archive-named subfolder(s) inside the other panel (async). Automatically appends suffixes if folder names collide. Supports optional `itemsToExtract` which accepts exact paths, wildcard patterns, or regular expressions.",
      "params": [
        "itemsToExtract? (array - optional list of paths, glob patterns or regular expressions (e.g. ['*.jpg','docs/*.txt','/^images\\/.*\\.jpg$/i']) inside the archive to extract)"
      ],
      "examples": [
        "await FM.decompressInSubfolderToOtherPanel()",
        "await FM.decompressInSubfolderToOtherPanel(['a/b.txt'])",
        "await FM.decompressInSubfolderToOtherPanel(['*.jpg','docs/*.txt']) // use wildcards to select by pattern",
        "await FM.decompressInSubfolderToOtherPanel(['/^images\\/.*\\.jpg$/i']) // use a regex (string literal form) to match entries"
      ]
    },
    "testArchive": {
      "desc": "Runs an integrity test on selected archive file(s) (async). Returns error if no archives are selected.",
      "params": [],
      "examples": ["await FM.testArchive()"]
    },
    "compressToActivePanel": {
      "desc": "Compress the current selection (files/folders) into a zip archive in the active panel (async). Returns error if no selection is made.",
      "params": [
        "itemsToCompress? (array - optional names, glob patterns or regular expressions (RegExp objects or '/pattern/flags' strings) e.g. ['*.jpg','docs/*.txt','/^IMG_\\\\d+\\.JPG$/i'] to filter the selected items)"
      ],
      "examples": [
        "await FM.compressToActivePanel()",
        "await FM.compressToActivePanel(['*.jpg','file.txt'])",
        "await FM.compressToActivePanel(['/^IMG_\\\\d+\\.JPG$/i'])"
      ]
    },
    "compressToOtherPanel": {
      "desc": "Compress the current selection (files/folders) into a zip archive in the other panel (async). Returns error if no selection is made.",
      "params": [
        "itemsToCompress? (array - optional names, glob patterns or regular expressions (RegExp objects or '/pattern/flags' strings) e.g. ['*.jpg','docs/*.txt','/^IMG_\\\\d+\\.JPG$/i'] to filter the selected items)"
      ],
      "examples": [
        "await FM.compressToOtherPanel()",
        "await FM.compressToOtherPanel(['*.jpg','file.txt'])",
        "await FM.compressToOtherPanel(['/^IMG_\\\\d+\\.JPG$/i'])"
      ]
    },
    "copyToActivePanel": {
      "desc": "Copies selected items from the other (inactive) panel into the active panel. Optional itemsToCopy filters which of the selected items should be copied; overwrite can be a boolean or canonical overwrite token which will be used by the UI when an overwrite prompt appears. If there is no selection in the source panel and itemsToCopy is provided, the filter will be applied against all items in the panel.",
      "params": [
        "itemsToCopy? (array - optional names, glob patterns or regular expressions (RegExp objects or '/pattern/flags' strings) e.g. ['*.jpg','docs/*.txt','/^IMG_\\\\d+\\.JPG$/i'] to filter the selected items)",
        "overwrite? (boolean|string - optional; boolean true -> overwrite / false -> skip; or string: 'overwrite'|'skip' or server policy tokens: 'if_newer','smaller_only','no_zero_length','size_differs','cancel')"
      ],
      "examples": [
        "await FM.copyToActivePanel()",
        "await FM.copyToActivePanel(['file.txt'])",
        "await FM.copyToActivePanel(['*.jpg','*.txt']) // use wildcards to select by pattern",
        "await FM.copyToActivePanel(['/^IMG_\\\\d+\\.JPG$/i']) // use regex string to select by regex (case-insensitive)",
        "await FM.copyToActivePanel(['file.txt'], true) // overwrite (no prompts)",
        "await FM.copyToActivePanel(['file.txt'], 'skip') // skip (no prompts)",
        "await FM.copyToActivePanel(null, true) // overwrite (no prompts)",
        "await FM.copyToActivePanel(null, 'overwrite') // overwrite (no prompts)",
        "await FM.copyToActivePanel(null, false) // skip (no prompts)",
        "await FM.copyToActivePanel(null, 'skip') // skip (no prompts)",
        "await FM.copyToActivePanel(null, 'if_newer') // copy only if dest missing or older",
        "await FM.copyToActivePanel(null, 'smaller_only') // replace dest if smaller",
        "await FM.copyToActivePanel(null, 'no_zero_length') // skip when source is zero-length",
        "await FM.copyToActivePanel(null, 'size_differs') // overwrite when sizes differ",
        "await FM.copyToActivePanel(null, 'cancel') // cancel the whole copy",
        "// combine itemsToCopy with an explicit decision:",
        "await FM.copyToActivePanel(['a.txt','b/c.jpg'], 'if_newer')"
      ]
    },
    "copyToOtherPanel": {
      "desc": "Copies selected items from the active panel to the other (inactive) panel. Optional itemsToCopy filters which of the selected items should be copied; overwrite can be a boolean or canonical overwrite token which will be used by the UI when an overwrite prompt appears. If there is no selection in the source panel and itemsToCopy is provided, the filter will be applied against all items in the panel.",
      "params": [
        "itemsToCopy? (array - optional names, glob patterns or regular expressions (RegExp objects or '/pattern/flags' strings) e.g. ['*.jpg','docs/*.txt','/^IMG_\\\\d+\\.JPG$/i'] to filter the selected items)",
        "overwrite? (boolean|string - optional; boolean true -> overwrite / false -> skip; or string: 'overwrite'|'skip' or server policy tokens: 'if_newer','smaller_only','no_zero_length','size_differs','cancel')"
      ],
      "examples": [
        "await FM.copyToOtherPanel()",
        "await FM.copyToOtherPanel(['file.txt'])",
        "await FM.copyToOtherPanel(['*.jpg','*.txt']) // use wildcards to select by pattern",
        "await FM.copyToOtherPanel(['/^IMG_\\\\d+\\.JPG$/i']) // use regex string to select by regex (case-insensitive)",
        "await FM.copyToOtherPanel(['file.txt'], true) // overwrite (no prompts)",
        "await FM.copyToOtherPanel(['file.txt'], 'skip') // skip (no prompts)",
        "await FM.copyToOtherPanel(null, true) // overwrite (no prompts)",
        "await FM.copyToOtherPanel(null, 'overwrite') // overwrite (no prompts)",
        "await FM.copyToOtherPanel(null, false) // skip (no prompts)",
        "await FM.copyToOtherPanel(null, 'skip') // skip (no prompts)",
        "await FM.copyToOtherPanel(null, 'if_newer') // copy only if dest missing or older",
        "await FM.copyToOtherPanel(null, 'smaller_only') // replace dest if smaller",
        "await FM.copyToOtherPanel(null, 'no_zero_length') // skip when source is zero-length",
        "await FM.copyToOtherPanel(null, 'size_differs') // overwrite when sizes differ",
        "await FM.copyToOtherPanel(null, 'cancel') // cancel the whole copy",
        "// combine itemsToCopy with an explicit decision:",
        "await FM.copyToOtherPanel(['a.txt','b/c.jpg'], 'if_newer')"
      ]
    },
    "moveToActivePanel": {
      "desc": "Moves selected items from the other (inactive) panel into the active panel. Optional itemsToMove filters which of the selected items should be moved; overwrite behaves like copy's overwrite parameter. If there is no selection in the source panel and itemsToMove is provided, the filter will be applied against all items in the panel.",
      "params": [
        "itemsToMove? (array - optional names, glob patterns or regular expressions (RegExp objects or '/pattern/flags' strings) e.g. ['*.jpg','docs/*.txt','/^IMG_\\d+\\.JPG$/i'] to filter the selected items)",
        "overwrite? (boolean|string - optional; boolean true -> overwrite / false -> skip; or string: 'overwrite'|'skip' or server policy tokens: 'if_newer','smaller_only','no_zero_length','size_differs','cancel')"
      ],
      "examples": [
        "await FM.moveToActivePanel()",
        "await FM.moveToActivePanel(['file.txt'])",
        "await FM.moveToActivePanel(['*.jpg','*.txt']) // use wildcards to select by pattern",
        "await FM.moveToActivePanel(['/^IMG_\\d+\\.JPG$/i']) // use regex string to select by regex (case-insensitive)",
        "await FM.moveToActivePanel(['file.txt'], true) // overwrite (no prompts)",
        "await FM.moveToActivePanel(['file.txt'], 'skip') // skip (no prompts)",
        "await FM.moveToActivePanel(null, true) // overwrite (no prompts)",
        "await FM.moveToActivePanel(null, 'overwrite') // overwrite (no prompts)",
        "await FM.moveToActivePanel(null, false) // skip (no prompts)",
        "await FM.moveToActivePanel(null, 'skip') // skip (no prompts)",
        "await FM.moveToActivePanel(null, 'if_newer') // copy only if dest missing or older",
        "await FM.moveToActivePanel(null, 'smaller_only') // replace dest if smaller",
        "await FM.moveToActivePanel(null, 'no_zero_length') // skip when source is zero-length",
        "await FM.moveToActivePanel(null, 'size_differs') // overwrite when sizes differ",
        "await FM.moveToActivePanel(null, 'cancel') // cancel the whole move",
        "// combine itemsToMove with an explicit decision:",
        "await FM.moveToActivePanel(['a.txt','b/c.jpg'], 'if_newer')"
      ]
    },
    "moveToOtherPanel": {
      "desc": "Moves selected items from the active panel into the other (inactive) panel. Optional itemsToMove filters which of the selected items should be moved; overwrite behaves like copy's overwrite parameter. If there is no selection in the source panel and itemsToMove is provided, the filter will be applied against all items in the panel.",
      "params": [
        "itemsToMove? (array - optional names, glob patterns or regular expressions (RegExp objects or '/pattern/flags' strings) e.g. ['*.jpg','docs/*.txt','/^IMG_\\d+\\.JPG$/i'] to filter the selected items)",
        "overwrite? (boolean|string - optional; boolean true -> overwrite / false -> skip; or string: 'overwrite'|'skip' or server policy tokens: 'if_newer','smaller_only','no_zero_length','size_differs','cancel')"
      ],
      "examples": [
        "await FM.moveToOtherPanel()",
        "await FM.moveToOtherPanel(['file.txt'])",
        "await FM.moveToOtherPanel(['*.jpg','*.txt']) // use wildcards to select by pattern",
        "await FM.moveToOtherPanel(['/^IMG_\\d+\\.JPG$/i']) // use regex string to select by regex (case-insensitive)",
        "await FM.moveToOtherPanel(['file.txt'], true) // overwrite (no prompts)",
        "await FM.moveToOtherPanel(['file.txt'], 'skip') // skip (no prompts)",
        "await FM.moveToOtherPanel(null, true) // overwrite (no prompts)",
        "await FM.moveToOtherPanel(null, 'overwrite') // overwrite (no prompts)",
        "await FM.moveToOtherPanel(null, false) // skip (no prompts)",
        "await FM.moveToOtherPanel(null, 'skip') // skip (no prompts)",
        "await FM.moveToOtherPanel(null, 'if_newer') // copy only if dest missing or older",
        "await FM.moveToOtherPanel(null, 'smaller_only') // replace dest if smaller",
        "await FM.moveToOtherPanel(null, 'no_zero_length') // skip when source is zero-length",
        "await FM.moveToOtherPanel(null, 'size_differs') // overwrite when sizes differ",
        "await FM.moveToOtherPanel(null, 'cancel') // cancel the whole move",
        "// combine itemsToMove with an explicit decision:",
        "await FM.moveToOtherPanel(['a.txt','b/c.jpg'], 'if_newer')"
      ]
    },
    "multiRenameInActivePanel": {
      "desc": "Applies multiple rename operations to items in the active panel using ordered renameActions array. Operations execute in array order. If `previewMode` is true (default false), shows colored console output with diff highlighting (green=added, red strikethrough=removed); if false, performs actual rename with progress modal. Optional `items` (string or array) filters which items to rename (supports exact names, wildcards like '*.jpg', or regex like '/^IMG_\\\\d+\\\\.JPG$/i'). If no selection and items provided, filters all panel items and renames the matches.",
      "params": [
        "items? (string|array - optional item name/pattern or array of patterns)",
        "renameActions (array - ordered list of rename operation objects)",
        "previewMode? (boolean - default false, true shows preview)"
      ],
      "examples": [
        "// Preview multi-rename with add_text operation",
        "await FM.multiRenameInActivePanel(null, [{type: 'add_text', params: {text: 'prefix_', position: 'start'}}], true)",
        "",
        "// Actual rename: add text at start",
        "await FM.multiRenameInActivePanel(null, [{type: 'add_text', params: {text: 'IMG_', position: 'start'}}])",
        "",
        "// Add text at end",
        "await FM.multiRenameInActivePanel(null, [{type: 'add_text', params: {text: '_backup', position: 'end'}}])",
        "",
        "// Add text at specific index (supports negative indices)",
        "await FM.multiRenameInActivePanel(null, [{type: 'add_text', params: {text: '-NEW', position: 'index', atIndex: 5}}])",
        "",
        "// Remove characters from start",
        "await FM.multiRenameInActivePanel(null, [{type: 'remove_text', params: {count: 4, position: 'start'}}])",
        "",
        "// Remove characters from end",
        "await FM.multiRenameInActivePanel(null, [{type: 'remove_text', params: {count: 3, position: 'end'}}])",
        "",
        "// Remove characters from index",
        "await FM.multiRenameInActivePanel(null, [{type: 'remove_text', params: {count: 2, position: 'index', atIndex: 3}}])",
        "",
        "// Find and replace (case-insensitive, match all)",
        "await FM.multiRenameInActivePanel(null, [{type: 'find_replace', params: {find: 'old', replace: 'new', useRegex: false, caseSensitive: false, matchAll: true}}])",
        "",
        "// Find and replace with regex",
        "await FM.multiRenameInActivePanel(null, [{type: 'find_replace', params: {find: '\\\\d+', replace: 'NUM', useRegex: true, caseSensitive: false, matchAll: true}}])",
        "",
        "// Find and replace (first occurrence only)",
        "await FM.multiRenameInActivePanel(null, [{type: 'find_replace', params: {find: 'photo', replace: 'image', useRegex: false, caseSensitive: true, matchAll: false}}])",
        "",
        "// Add sequence numbers with padding",
        "await FM.multiRenameInActivePanel(null, [{type: 'sequence', params: {start: 1, step: 1, padding: 3, position: 'start', prefix: 'File_', suffix: ''}}])",
        "",
        "// Add sequence at end with custom start and step",
        "await FM.multiRenameInActivePanel(null, [{type: 'sequence', params: {start: 10, step: 5, padding: 2, position: 'end', prefix: '_', suffix: ''}}])",
        "",
        "// Add sequence at index",
        "await FM.multiRenameInActivePanel(null, [{type: 'sequence', params: {start: 1, step: 1, padding: 4, position: 'index', atIndex: 0, prefix: '[', suffix: ']'}}])",
        "",
        "// Add current date/time at start",
        "await FM.multiRenameInActivePanel(null, [{type: 'date_time', params: {format: 'YYYYMMDD', source: 'current', position: 'start', prefix: '', suffix: '_'}}])",
        "",
        "// Add file modification date at end",
        "await FM.multiRenameInActivePanel(null, [{type: 'date_time', params: {format: 'YYYY-MM-DD', source: 'modified', position: 'end', prefix: '_', suffix: ''}}])",
        "",
        "// Add custom date format at index",
        "await FM.multiRenameInActivePanel(null, [{type: 'date_time', params: {format: 'YYYY-MM-DD_HHmmss', source: 'current', position: 'index', atIndex: 0, prefix: '[', suffix: ']'}}])",
        "",
        "// Change case to uppercase",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'uppercase'}}])",
        "",
        "// Change case to lowercase",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Change case to title case",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'title'}}])",
        "",
        "// Change case to sentence case",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'sentence'}}])",
        "",
        "// Change case to camelCase",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'camel'}}])",
        "",
        "// Change case to PascalCase",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'pascal'}}])",
        "",
        "// Change case to snake_case",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'snake'}}])",
        "",
        "// Change case to kebab-case",
        "await FM.multiRenameInActivePanel(null, [{type: 'case_change', params: {mode: 'kebab'}}])",
        "",
        "// Trim whitespace from both sides",
        "await FM.multiRenameInActivePanel(null, [{type: 'trim', params: {mode: 'both', collapseSpaces: false}}])",
        "",
        "// Trim whitespace from start",
        "await FM.multiRenameInActivePanel(null, [{type: 'trim', params: {mode: 'start', collapseSpaces: false}}])",
        "",
        "// Trim whitespace from end and collapse multiple spaces",
        "await FM.multiRenameInActivePanel(null, [{type: 'trim', params: {mode: 'end', collapseSpaces: true}}])",
        "",
        "// Swap parts separated by delimiter",
        "await FM.multiRenameInActivePanel(null, [{type: 'swap', params: {delimiter: ' - ', mode: 'swap', aIndex: 0, bIndex: 1}}])",
        "",
        "// Swap with custom delimiter and indices",
        "await FM.multiRenameInActivePanel(null, [{type: 'swap', params: {delimiter: '_', mode: 'swap', aIndex: 0, bIndex: 2}}])",
        "",
        "// Reorder parts by custom order",
        "await FM.multiRenameInActivePanel(null, [{type: 'swap', params: {delimiter: '-', mode: 'reorder', order: '2,0,1'}}])",
        "",
        "// Multiple operations in order (add prefix, then sequence, then lowercase)",
        "await FM.multiRenameInActivePanel(null, [{type: 'add_text', params: {text: 'photo_', position: 'start'}}, {type: 'sequence', params: {start: 1, step: 1, padding: 3, position: 'end', prefix: '_', suffix: ''}}, {type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Filter to only rename .jpg files using STRING (no selection needed)",
        "await FM.multiRenameInActivePanel('*.jpg', [{type: 'date_time', params: {format: 'YYYYMMDD', source: 'current', position: 'start', prefix: '', suffix: '_'}}])",
        "",
        "// Filter with array of patterns",
        "await FM.multiRenameInActivePanel(['*.jpg', '*.png'], [{type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Filter with regex (string form) - no selection needed",
        "await FM.multiRenameInActivePanel('/^IMG_\\\\d+\\\\.JPG$/i', [{type: 'add_text', params: {text: 'Photo_', position: 'start'}}])",
        "",
        "// Filter with regex in array and apply multiple operations",
        "await FM.multiRenameInActivePanel(['/^IMG_\\\\d+\\\\.JPG$/i'], [{type: 'add_text', params: {text: 'Photo_', position: 'start'}}, {type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Disable an operation by setting active: false",
        "await FM.multiRenameInActivePanel(null, [{type: 'add_text', params: {text: 'test_', position: 'start'}, active: false}, {type: 'case_change', params: {mode: 'uppercase'}}], true)"
      ]
    },
    "multiRenameInOtherPanel": {
      "desc": "Applies multiple rename operations to items in the other (inactive) panel using ordered renameActions array. Operations execute in array order. If `previewMode` is true (default false), shows colored console output with diff highlighting (green=added, red strikethrough=removed); if false, performs actual rename with progress modal. Optional `items` (string or array) filters which items to rename (supports exact names, wildcards like '*.jpg', or regex like '/^IMG_\\\\d+\\\\.JPG$/i'). If no selection and items provided, filters all panel items and renames the matches.",
      "params": [
        "items? (string|array - optional item name/pattern or array of patterns)",
        "renameActions (array - ordered list of rename operation objects)",
        "previewMode? (boolean - default false, true shows preview)"
      ],
      "examples": [
        "// Preview multi-rename in other panel with add_text operation",
        "await FM.multiRenameInOtherPanel(null, [{type: 'add_text', params: {text: 'backup_', position: 'start'}}], true)",
        "",
        "// Actual rename: add text at start",
        "await FM.multiRenameInOtherPanel(null, [{type: 'add_text', params: {text: 'IMG_', position: 'start'}}])",
        "",
        "// Add text at end",
        "await FM.multiRenameInOtherPanel(null, [{type: 'add_text', params: {text: '_backup', position: 'end'}}])",
        "",
        "// Add text at specific index (supports negative indices)",
        "await FM.multiRenameInOtherPanel(null, [{type: 'add_text', params: {text: '-NEW', position: 'index', atIndex: 5}}])",
        "",
        "// Remove characters from start",
        "await FM.multiRenameInOtherPanel(null, [{type: 'remove_text', params: {count: 4, position: 'start'}}])",
        "",
        "// Remove characters from end",
        "await FM.multiRenameInOtherPanel(null, [{type: 'remove_text', params: {count: 3, position: 'end'}}])",
        "",
        "// Remove characters from index",
        "await FM.multiRenameInOtherPanel(null, [{type: 'remove_text', params: {count: 2, position: 'index', atIndex: 3}}])",
        "",
        "// Find and replace (case-insensitive, match all)",
        "await FM.multiRenameInOtherPanel(null, [{type: 'find_replace', params: {find: 'old', replace: 'new', useRegex: false, caseSensitive: false, matchAll: true}}])",
        "",
        "// Find and replace with regex",
        "await FM.multiRenameInOtherPanel(null, [{type: 'find_replace', params: {find: '\\\\d+', replace: 'NUM', useRegex: true, caseSensitive: false, matchAll: true}}])",
        "",
        "// Find and replace (first occurrence only)",
        "await FM.multiRenameInOtherPanel(null, [{type: 'find_replace', params: {find: 'photo', replace: 'image', useRegex: false, caseSensitive: true, matchAll: false}}])",
        "",
        "// Add sequence numbers with padding",
        "await FM.multiRenameInOtherPanel(null, [{type: 'sequence', params: {start: 1, step: 1, padding: 3, position: 'start', prefix: 'File_', suffix: ''}}])",
        "",
        "// Add sequence at end with custom start and step",
        "await FM.multiRenameInOtherPanel(null, [{type: 'sequence', params: {start: 10, step: 5, padding: 2, position: 'end', prefix: '_', suffix: ''}}])",
        "",
        "// Add sequence at index",
        "await FM.multiRenameInOtherPanel(null, [{type: 'sequence', params: {start: 1, step: 1, padding: 4, position: 'index', atIndex: 0, prefix: '[', suffix: ']'}}])",
        "",
        "// Add current date/time at start",
        "await FM.multiRenameInOtherPanel(null, [{type: 'date_time', params: {format: 'YYYYMMDD', source: 'current', position: 'start', prefix: '', suffix: '_'}}])",
        "",
        "// Add file modification date at end",
        "await FM.multiRenameInOtherPanel(null, [{type: 'date_time', params: {format: 'YYYY-MM-DD', source: 'modified', position: 'end', prefix: '_', suffix: ''}}])",
        "",
        "// Add custom date format at index",
        "await FM.multiRenameInOtherPanel(null, [{type: 'date_time', params: {format: 'YYYY-MM-DD_HHmmss', source: 'current', position: 'index', atIndex: 0, prefix: '[', suffix: ']'}}])",
        "",
        "// Change case to uppercase",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'uppercase'}}])",
        "",
        "// Change case to lowercase",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Change case to title case",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'title'}}])",
        "",
        "// Change case to sentence case",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'sentence'}}])",
        "",
        "// Change case to camelCase",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'camel'}}])",
        "",
        "// Change case to PascalCase",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'pascal'}}])",
        "",
        "// Change case to snake_case",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'snake'}}])",
        "",
        "// Change case to kebab-case",
        "await FM.multiRenameInOtherPanel(null, [{type: 'case_change', params: {mode: 'kebab'}}])",
        "",
        "// Trim whitespace from both sides",
        "await FM.multiRenameInOtherPanel(null, [{type: 'trim', params: {mode: 'both', collapseSpaces: false}}])",
        "",
        "// Trim whitespace from start",
        "await FM.multiRenameInOtherPanel(null, [{type: 'trim', params: {mode: 'start', collapseSpaces: false}}])",
        "",
        "// Trim whitespace from end and collapse multiple spaces",
        "await FM.multiRenameInOtherPanel(null, [{type: 'trim', params: {mode: 'end', collapseSpaces: true}}])",
        "",
        "// Swap parts separated by delimiter",
        "await FM.multiRenameInOtherPanel(null, [{type: 'swap', params: {delimiter: ' - ', mode: 'swap', aIndex: 0, bIndex: 1}}])",
        "",
        "// Swap with custom delimiter and indices",
        "await FM.multiRenameInOtherPanel(null, [{type: 'swap', params: {delimiter: '_', mode: 'swap', aIndex: 0, bIndex: 2}}])",
        "",
        "// Reorder parts by custom order",
        "await FM.multiRenameInOtherPanel(null, [{type: 'swap', params: {delimiter: '-', mode: 'reorder', order: '2,0,1'}}])",
        "",
        "// Multiple operations in order (add prefix, then sequence, then lowercase)",
        "await FM.multiRenameInOtherPanel(null, [{type: 'add_text', params: {text: 'photo_', position: 'start'}}, {type: 'sequence', params: {start: 1, step: 1, padding: 3, position: 'end', prefix: '_', suffix: ''}}, {type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Filter to only rename .txt files using STRING (no selection needed)",
        "await FM.multiRenameInOtherPanel('*.txt', [{type: 'date_time', params: {format: 'YYYYMMDD', source: 'current', position: 'start', prefix: '', suffix: '_'}}])",
        "",
        "// Filter with array of patterns",
        "await FM.multiRenameInOtherPanel(['*.txt', '*.md'], [{type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Filter with regex (string form) - no selection needed",
        "await FM.multiRenameInOtherPanel('/^IMG_\\\\d+\\\\.JPG$/i', [{type: 'add_text', params: {text: 'Photo_', position: 'start'}}])",
        "",
        "// Filter with regex in array and apply multiple operations",
        "await FM.multiRenameInOtherPanel(['/^IMG_\\\\d+\\\\.JPG$/i'], [{type: 'add_text', params: {text: 'Photo_', position: 'start'}}, {type: 'case_change', params: {mode: 'lowercase'}}])",
        "",
        "// Disable an operation by setting active: false",
        "await FM.multiRenameInOtherPanel(null, [{type: 'add_text', params: {text: 'test_', position: 'start'}, active: false}, {type: 'case_change', params: {mode: 'uppercase'}}], true)"
      ]
    },
    "singleRenameInActivePanel": {
      "desc": "Renames a single selected item in the active panel to the specified `newValue`. If `previewMode` is true (default false), shows colored console output with diff highlighting (green=added, red strikethrough=removed); if false, performs actual rename. Returns error if no item is selected or if multiple items are selected.",
      "params": [
        "newValue (string - the new name for the item)",
        "previewMode? (boolean - default false, true shows preview)"
      ],
      "examples": [
        "// Preview rename",
        "await FM.singleRenameInActivePanel('NewFileName.txt', true)",
        "",
        "// Actual rename",
        "await FM.singleRenameInActivePanel('RenamedFile.txt')",
        "",
        "// Rename with special characters",
        "await FM.singleRenameInActivePanel('File [2024-01-01].txt')",
        "",
        "// Rename folder",
        "await FM.singleRenameInActivePanel('NewFolderName')"
      ]
    },
    "singleRenameInOtherPanel": {
      "desc": "Renames a single selected item in the other (inactive) panel to the specified `newValue`. If `previewMode` is true (default false), shows colored console output with diff highlighting (green=added, red strikethrough=removed); if false, performs actual rename. Returns error if no item is selected or if multiple items are selected.",
      "params": [
        "newValue (string - the new name for the item)",
        "previewMode? (boolean - default false, true shows preview)"
      ],
      "examples": [
        "// Preview rename in other panel",
        "await FM.singleRenameInOtherPanel('NewName.jpg', true)",
        "",
        "// Actual rename in other panel",
        "await FM.singleRenameInOtherPanel('Document.pdf')",
        "",
        "// Rename with date in name",
        "await FM.singleRenameInOtherPanel('Report_2024-01-15.docx')"
      ]
    }
  },
  "properties": {
    "name": {
      "desc": "package name (string - e.g., 'web-file-manager')"
    },
    "version": {
      "desc": "package version (string - e.g., '1.1.8')"
    },
    "buildType": {
      "desc": "current build mode (string - 'Node:Dev' | 'Electron:Dev' | 'Electron:Dist')"
    }
  }
}
